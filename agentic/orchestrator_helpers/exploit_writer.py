"""Exploit node writer for Neo4j.

Creates Exploit nodes in the graph database when exploitation succeeds.
Uses MERGE for idempotency — calling twice with the same parameters
produces only one node.
"""

import re
import time
import logging
from typing import Optional, List, Dict, Any

from neo4j import GraphDatabase

logger = logging.getLogger(__name__)

# Module-level driver singleton
_driver = None


def _get_driver(uri: str, user: str, password: str):
    """Get or create a singleton Neo4j driver."""
    global _driver
    if _driver is None:
        _driver = GraphDatabase.driver(uri, auth=(user, password))
    return _driver


def close_driver():
    """Close the Neo4j driver (call on shutdown)."""
    global _driver
    if _driver is not None:
        _driver.close()
        _driver = None


def _generate_exploit_id(
    attack_type: str,
    target_ip: str,
    cve_ids: Optional[List[str]] = None,
    username: Optional[str] = None,
    port: Optional[int] = None,
) -> str:
    """Generate a deterministic exploit ID for MERGE idempotency.

    Uses a 5-minute time bucket so that the same exploit detected
    by both regex and LLM within the same window produces the same ID.
    """
    # 5-minute bucket (300 seconds)
    time_bucket = int(time.time()) // 300

    parts = [f"exploit-{attack_type}-{target_ip or 'unknown'}"]

    if attack_type == "cve_exploit" and cve_ids:
        # Sort CVE IDs for determinism
        parts.append("-".join(sorted(cve_ids)))
    elif attack_type == "brute_force":
        parts.append(f"{username or 'anon'}@{port or 0}")

    parts.append(str(time_bucket))
    return "-".join(parts)


def _extract_metasploit_info(execution_trace: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Extract Metasploit module, payload, and commands from execution trace."""
    info = {
        "metasploit_module": None,
        "payload": None,
        "commands_used": [],
    }

    for step in execution_trace:
        tool_name = step.get("tool_name", "")
        tool_args = step.get("tool_args") or {}
        command = tool_args.get("command", "")

        if tool_name != "metasploit_console" or not command:
            continue

        info["commands_used"].append(command)

        # Extract module from 'use <module>' command
        use_match = re.search(r'use\s+(exploit/\S+|auxiliary/\S+)', command)
        if use_match:
            info["metasploit_module"] = use_match.group(1)

        # Extract payload from 'set PAYLOAD <payload>'
        payload_match = re.search(r'set\s+PAYLOAD\s+(\S+)', command, re.IGNORECASE)
        if payload_match:
            info["payload"] = payload_match.group(1)

    return info


def _build_exploit_report(
    attack_type: str,
    target_ip: str,
    target_port: Optional[int],
    cve_ids: Optional[List[str]],
    username: Optional[str],
    session_id: Optional[int],
    evidence: str,
    msf_info: Dict[str, Any],
) -> str:
    """Build a structured exploitation report."""
    lines = []

    if attack_type == "cve_exploit":
        cve_str = ", ".join(cve_ids) if cve_ids else "Unknown CVE"
        lines.append(f"Successfully exploited {cve_str} on {target_ip}")
        if target_port:
            lines.append(f"Target port: {target_port}")
        if msf_info.get("metasploit_module"):
            lines.append(f"Module: {msf_info['metasploit_module']}")
        if msf_info.get("payload"):
            lines.append(f"Payload: {msf_info['payload']}")
        if session_id is not None:
            lines.append(f"Session established: {session_id}")
    else:
        lines.append(f"Brute force credential discovery on {target_ip}:{target_port or '?'}")
        if username:
            lines.append(f"Compromised account: {username}")

    if evidence:
        lines.append(f"Evidence: {evidence}")

    return "\n".join(lines)


def create_exploit_node(
    neo4j_uri: str,
    neo4j_user: str,
    neo4j_password: str,
    user_id: str,
    project_id: str,
    attack_type: str = "cve_exploit",
    target_ip: Optional[str] = None,
    target_port: Optional[int] = None,
    cve_ids: Optional[List[str]] = None,
    session_id: Optional[int] = None,
    username: Optional[str] = None,
    password: Optional[str] = None,
    evidence: str = "",
    execution_trace: Optional[List[Dict[str, Any]]] = None,
) -> None:
    """Create an Exploit node in Neo4j with relationships to CVE/IP/Port.

    Uses MERGE for idempotency — safe to call multiple times for the same
    exploit event (both regex and LLM detection can trigger this).

    Args:
        neo4j_uri: Neo4j connection URI
        neo4j_user: Neo4j username
        neo4j_password: Neo4j password
        user_id: Tenant user ID
        project_id: Tenant project ID
        attack_type: "cve_exploit" or "brute_force"
        target_ip: IP address of the exploited target
        target_port: Port number targeted
        cve_ids: List of CVE IDs exploited (for cve_exploit)
        session_id: Metasploit session ID (if applicable)
        username: Compromised username (for brute_force)
        password: Compromised password (for brute_force)
        evidence: LLM-provided evidence of exploitation success
        execution_trace: Execution steps for extracting MSF info
    """
    if not neo4j_uri or not neo4j_password:
        logger.warning("Neo4j credentials not configured — skipping Exploit node creation")
        return

    driver = _get_driver(neo4j_uri, neo4j_user, neo4j_password)

    # Extract Metasploit info from execution trace
    msf_info = _extract_metasploit_info(execution_trace or [])

    # Generate deterministic ID
    exploit_id = _generate_exploit_id(attack_type, target_ip, cve_ids, username, target_port)

    # Build report
    report = _build_exploit_report(
        attack_type, target_ip, target_port, cve_ids,
        username, session_id, evidence, msf_info,
    )

    # Build node properties
    props = {
        "id": exploit_id,
        "user_id": user_id,
        "project_id": project_id,
        "attack_type": attack_type,
        "severity": "critical",
        "target_ip": target_ip,
        "report": report,
        "evidence": evidence,
    }

    if target_port is not None:
        props["target_port"] = target_port
    if cve_ids:
        props["cve_ids"] = cve_ids
    if msf_info.get("metasploit_module"):
        props["metasploit_module"] = msf_info["metasploit_module"]
    if msf_info.get("payload"):
        props["payload"] = msf_info["payload"]
    if msf_info.get("commands_used"):
        props["commands_used"] = msf_info["commands_used"]
    if session_id is not None:
        props["session_id"] = session_id
    if username:
        props["username"] = username
    if password:
        props["password"] = password

    # Build Cypher query
    cypher_parts = [
        "MERGE (e:Exploit {id: $id})",
        "ON CREATE SET e += $props, e.created_at = datetime()",
        "ON MATCH SET e.updated_at = datetime()",
    ]

    # Connect to IP node
    if target_ip:
        cypher_parts.append(
            "WITH e "
            "OPTIONAL MATCH (ip:IP {address: $target_ip, project_id: $project_id}) "
            "FOREACH (_ IN CASE WHEN ip IS NOT NULL THEN [1] ELSE [] END | "
            "  MERGE (e)-[:TARGETED_IP]->(ip))"
        )

    # Connect to CVE nodes (for CVE exploit path)
    if attack_type == "cve_exploit" and cve_ids:
        for i, cve_id in enumerate(cve_ids):
            param_name = f"cve_id_{i}"
            props[param_name] = cve_id
            cypher_parts.append(
                f"WITH e "
                f"OPTIONAL MATCH (c{i}:CVE {{id: ${param_name}}}) "
                f"FOREACH (_ IN CASE WHEN c{i} IS NOT NULL THEN [1] ELSE [] END | "
                f"  MERGE (e)-[:EXPLOITED_CVE]->(c{i}))"
            )

    # Connect to Port node (for brute force path)
    if attack_type == "brute_force" and target_ip and target_port is not None:
        cypher_parts.append(
            "WITH e "
            "OPTIONAL MATCH (ip2:IP {address: $target_ip, project_id: $project_id})"
            "<-[:BELONGS_TO]-(p:Port {number: $target_port}) "
            "FOREACH (_ IN CASE WHEN p IS NOT NULL THEN [1] ELSE [] END | "
            "  MERGE (e)-[:VIA_PORT]->(p))"
        )

    cypher = "\n".join(cypher_parts)

    # Add all props to params
    params = {
        "id": exploit_id,
        "props": props,
        "target_ip": target_ip,
        "project_id": project_id,
        "target_port": target_port,
    }
    # Add CVE ID params
    for key, value in props.items():
        if key.startswith("cve_id_"):
            params[key] = value

    with driver.session() as session:
        session.run(cypher, params)

    logger.info(
        f"[{user_id}/{project_id}] Exploit node created/updated: "
        f"{exploit_id} ({attack_type}, target={target_ip})"
    )
